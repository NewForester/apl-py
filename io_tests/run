#!/bin/bash --posix
#
# exercise the input and output functions of the APL Shell
#

error() { echo -e "\e[31m$@\e[0m"; }
note()  { echo -e "\e[32m$@\e[0m"; }

# change directory to that containing this script

cd ${0%/*};

# do not assume the intepreter is on the PATH

for APL in apl.py ./apl.py ../apl.py "error APL intepreter not found"; do
    which ${APL} > /dev/null && break;
done

# helper functions

exec 8<&0;
exec 9<&1;

function invoke
{
  echo;
  echo "bash $" "$@" >&9;
  eval "$@" <&8;
  echo;
}

function narrative
{
    plus="++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++";

    echo;
    echo -e "\e[34m${plus}\e[0m";
    cat;
    read -p "Press enter to continue " junk <&8;
    echo -e "\e[34m${plus}\e[0m";
    echo;
}

function herald
{
    echo "------------------------------------------------------------------------";
    echo -e "\e[33m$@\e[0m";
    echo "------------------------------------------------------------------------";
}

if [[ $# == 0 ]]; then
	narrative <<- EOF
	These are tests of apl-py's implementation of those APL operations that
	output more that one result.

	That is ⋄, ⎕←, ⍞←, ⎕, ⍞ and combinations thereof.

	Not only do the tests check the correct values are output but also
	that newlines do or not appear between values, as appropriate.

	Therefore the tests log their output and compare it with a reference
	file rather than rely on visual inspection.

	The tests check the implementation of the input and output operators.

	Input is redirected to a file to ensure the same data is always input
	the same way so the comparison of log file with reference is reliable.
	EOF
    steps="1 2";
else
    steps="$@";
fi

for step in ${steps}; do
    case ${step} in
      (1 | test_separator)
        narrative <<- EOF
	The first test case is a simple test of the expresssion separator (⋄).
	EOF

        herald "Test Case 1 - Test ⋄ (expression separator)";
        test=test_separator;
        invoke ./"${test}.apl" '&>' "${test}.log";
        invoke diff "${test}.log" "${test}.ref";
        ;;

      (2 | test_output)
        narrative <<- EOF
	The next two test cases check the use of ⎕← and ⍞← for output.
	EOF

        herald "Test Case 2a - Test ⎕← (output operator)";
        test=test_output_a;
        invoke ./"${test}.apl" '&>' "${test}.log";
        invoke diff "${test}.log" "${test}.ref";

        herald "Test Case 2b - Test ⍞← (output operator)";
        test=test_output_b;
        invoke ./"${test}.apl" '&>' "${test}.log";
        invoke diff "${test}.log" "${test}.ref";
        ;;

      (3 | test_input)
        narrative <<- EOF
	The next two test cases check the use of ⎕ and ⍞ for input.
	The 'user input' is taken from a file.
	EOF

        herald "Test Case 3a - Test ⎕ (input operator)";
        test=test_input_a;
        invoke ./"${test}.apl" '<' "${test}.inp" '&>' "${test}.log";
        invoke diff "${test}.log" "${test}.ref";

        herald "Test Case 3b - Test ⍞ (input operator)";
        test=test_input_b;
        invoke ./"${test}.apl" '<' "${test}.inp" '&>' "${test}.log";
        invoke diff "${test}.log" "${test}.ref";
        ;;
    esac
done

# EOF
