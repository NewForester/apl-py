#!/bin/bash --posix
##
##  Goal:       exercise the input and output operators of the APL shell
##
##  All tests record their output and compare it with a reference file.  There
##  should be no differences.  At the end, the script reports either "ALL OK"
##  or "Something went awry".
##
##  Use:        ./io_tests/run [-a | -as] [nn ... ]
##
##  where   nn is in the range [1,3] and designates which test cases to run
##          if omitted, defaults to all test cases
##
##  Flags:  -a      more automation - no prompting to inform the tester of
##                  what is going on
##          -aa     even more automation - scripts that require manual
##                  intervention (if any) are skipped
##

# print out header comment &C

usage() { (sed -e "/^###/d" -e "/^##/!d" $0 && echo -e "\e[35m${0##*/}: \e[31m$@\e[0m") >&2; }
error() { echo -e "\e[31m$@\e[0m"; }
note()  { echo -e "\e[32m$@\e[0m"; }

# process options

while [[ "${1::1}" == "-" ]]; do
    case $1 in
      (-aa)
        nopause=$1;
        noprompt=$1; shift;
        ;;
      (-a)
        noprompt=$1; shift;
        ;;
      (--help)
        usage "I hope that was helpful";
        exit 1;
        ;;
      (*)
        usage "bad option \"$1\"";
        exit 1;
        ;;
    esac
done

# change directory to that containing this script

cd ${0%/*};

# do not assume the intepreter is on the PATH

for APL in apl.py ./apl.py ../apl.py "error APL intepreter not found"; do
    which ${APL} > /dev/null && break;
done

# helper functions

exec 8<&0;
exec 9<&1;

function invoke
{
  echo;
  echo "bash $" "$@" >&9;
  eval "$@" <&8;
  [[ $? -ne 0 ]] && allok=$1;
  echo;
}

plus="++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++";

function narrative
{
    echo;
    echo -e "\e[34m${plus}\e[0m";
    cat;
    [[ -z "${noprompt}" ]] && read -p "Press enter to continue " junk <&8;
    echo -e "\e[34m${plus}\e[0m";
    echo;
}

function herald
{
    echo "------------------------------------------------------------------------";
    echo -e "\e[33m$@\e[0m";
    echo "------------------------------------------------------------------------";
}

function summary
{
    echo;
    echo -e "\e[34m${plus}\e[0m";
    [[ -z "${allok}" ]] && note "ALL OK" || error "Something went awry";
    echo -e "\e[34m${plus}\e[0m";
    echo;
}

if [[ $# == 0 ]]; then
	narrative <<- EOF
	These are tests of apl-py's implementation of those APL operations that
	output more that one result.

	That is ⋄, ⎕←, ⍞←, ⎕, ⍞ and combinations thereof.

	Not only do the tests check the correct values are output but also
	that newlines do or not appear between values, as appropriate.

	The tests check the implementation of the input and output operators.

	Input is redirected to a file to ensure the same data is always input
	the same way so the comparison of log file with reference is reliable.
	EOF
    steps="1 2 3";
else
    steps="$@";
fi

for step in ${steps}; do
    case ${step} in
      (1 | test_separator)
        narrative <<- EOF
	The first test case is a simple test of the expresssion separator (⋄).
	EOF

        nn=1;
        herald "Test Case ${nn} - Test ⋄ (expression separator)";
        invoke ./"test_${nn}.apl" '&>' "case_${nn}.out";
        invoke diff "case_${nn}.out" "test_${nn}.ref";
        ;;

      (2 | test_output)
        narrative <<- EOF
	The next two test cases check the use of ⎕← and ⍞← for output.
	EOF

        nn=2a;
        herald "Test Case ${nn} - Test ⎕← (output operator)";
        invoke ./"test_${nn}.apl" '&>' "case_${nn}.out";
        invoke diff "case_${nn}.out" "test_${nn}.ref";

        nn=2b;
        herald "Test Case ${nn} - Test ⍞← (output operator)";
        invoke ./"test_${nn}.apl" '&>' "case_${nn}.out";
        invoke diff "case_${nn}.out" "test_${nn}.ref";
        ;;

      (3 | test_input)
        narrative <<- EOF
	The next two test cases check the use of ⎕ and ⍞ for input.
	The 'user input' is taken from a file.
	EOF

        nn=3a;
        herald "Test Case ${nn} - Test ⎕ (input operator)";
        invoke ./"test_${nn}.apl" '<' "test_${nn}.inp" '&>' "case_${nn}.out";
        invoke diff "case_${nn}.out" "test_${nn}.ref";

        nn=3b;
        herald "Test Case ${nn} - Test ⍞ (input operator)";
        invoke ./"test_${nn}.apl" '<' "test_${nn}.inp" '&>' "case_${nn}.out";
        invoke diff "case_${nn}.out" "test_${nn}.ref";
        ;;
    esac
done

summary;

# EOF
