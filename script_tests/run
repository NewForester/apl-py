#!/bin/bash --posix
#
# exercise the scripting ability of the APL Python intepreter
#

error() { echo -e "\e[31m$@\e[0m"; }
note()  { echo -e "\e[32m$@\e[0m"; }

# change directory to that containing this script

cd ${0%/*};

# do not assume the intepreter is on the PATH

for APL in apl.py ./apl.py ../apl.py "error APL intepreter not found"; do
    which ${APL} > /dev/null && break;
done

# helper functions

exec 8<&0;
exec 9<&1;

function invoke
{
  echo;
  echo "bash $" "$@" >&9;
  eval "$@" <&8;
  echo;
}

function narrative
{
    plus="++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++";

    echo;
    echo -e "\e[34m${plus}\e[0m";
    cat;
    read -p "Press enter to continue " junk <&8;
    echo -e "\e[34m${plus}\e[0m";
    echo;
}

function herald
{
    echo "------------------------------------------------------------------------";
    echo -e "\e[33m$@\e[0m";
    echo "------------------------------------------------------------------------";
}

if [[ $# == 0 ]]; then
	narrative <<- EOF
	These are tests of apl-py's execution of scripts rather than interactive use.

	The emphasis is less on 'are expressions evaluated the same way' but on:
	    - are command line flags handled properly
	    - do the echoing of input and suppression on prompts work are expected ?
	    - does the redirection of input work correctly ?

	Three cases are recognised:
	    a) pure and simple redirection of stdin using < and |
	    b) invocation with flags, such as -f file to read expression from file
	    c) turning a file into a script using the familiar #! first line

	All three have their uses.  If these tests prefer b) it is only because it
	allows test cases to be built using fewer external files.

	The APL command )OFF will cause the interpreter to exit:  anything that follows
	is ignored.  If there is no )OFF, the interpreter may enter interactive mode or
	interpret the remaining command line arguments as an expression.

	Entering interactive mode requires tester intervention to exit the interpreter
	before the test can move on to the next test case.  This is disconcerting since
	the prompt is six innocent spaces.  Watch out for the copyright banner.
	EOF
    steps="1 2 3 4 5 6 7 8 9";
else
    steps="$@";
fi

for step in ${steps}; do
    case ${step} in
      (1)
        narrative <<- EOF
	The first test cases are without scripts to check interactive
	operation still works.
	EOF

        herald "Test Case 1a - Invoke interactive mode - no script";
        note "... type ^D to exit the APL interpreter";
        invoke "${APL}";

        herald "Test Case 1b - Evaluate a command line expression - no script";
        invoke "${APL}" 1 2 3 × 3 2 1
        ;;

      (2)
        narrative <<- EOF
	The following test cases check simple script invocation.  The scripts
	'self-terminate' as each contains the )OFF system command.
	EOF

        herald "Test Case 2a - Execute script from stdin redirected using '<'";
        invoke "${APL}" '<' test_2.txt '&>' "case_2a.log";
        invoke diff case_2a.log test_2.ref;

        herald "Test Case 2b - Execute script from stdin redirected using '|'";
        invoke cat test_2.txt '|' "${APL}" '&>' "case_2b.log";
        invoke diff case_2b.log test_2.ref;

        herald "Test Case 2c - Execute script using command line flag";
        invoke "${APL}" -f test_2.txt '&>' "case_2c.log";
        invoke diff case_2c.log test_2.ref;

        herald "Test Case 2d - Execute implicit script using #!";
        invoke ./test_2.apl '&>' "case_2d.log";
        invoke diff case_2d.log test_2.ref;
        ;;

      (3)
        narrative <<- EOF
	The following test cases check what happens when a script does not
	self-terminate. The scripts are as before but the )OFF command
	had been commented out.
	EOF

        herald "Test Case 3a - Execute script from stdin redirected using '<'";
        invoke "${APL}" '<' test_3.txt '&>' "case_3a.log";
        invoke diff case_3a.log test_3.ref;

        herald "Test Case 3b - Execute script from stdin redirected using '|'";
        invoke cat test_3.txt '|' "${APL}" '&>' "case_3b.log";
        invoke diff case_3b.log test_3.ref;

        herald "Test Case 3c - Execute script using command line flag";
        note "... type ^D to exit the APL interpreter";
        invoke "${APL}" -f test_3.txt '&>' "case_3c.log";
        invoke diff case_3c.log test_3i.ref;

        herald "Test Case 3d - Execute implicit script using #!";
        note "... type ^D to exit the APL interpreter";
        invoke ./test_3.apl '&>' "case_3d.log";
        invoke diff case_3d.log test_3i.ref;
        ;;

      (4)
        narrative <<- EOF
	The following test cases check what happens when a script is used
	in conjunction with a command line expression.
	EOF

        herald "Test Case 4a - Execute script from stdin redirected using '<'";
        invoke "${APL}" 16 ÷ 4 '<' test_4.txt '&>' "case_4a.log";
        invoke diff case_4a.log test_4.ref;

        herald "Test Case 4b - Execute script from stdin redirected using '|'";
        invoke cat test_4.txt '|' "${APL}" 16 ÷ 4 '&>' "case_4b.log";
        invoke diff case_4b.log test_4.ref;

        herald "Test Case 4c - Execute script using command line flag";
        invoke "${APL}" -f test_4.txt -- 16 ÷ 4 '&>' "case_4c.log";
        invoke diff case_4c.log test_4.ref;

        herald "Test Case 4d - Execute implicit script using #!";
        invoke ./test_4.apl -- 16 ÷ 4  '&>' "case_4d.log";
        invoke diff case_4d.log test_4.ref;
        ;;

      (5)
        narrative <<- EOF
	The following test cases check what happens when a script is used
	in conjunction with a command line expression and the -s option is
	used to run in silent mode
	EOF

        herald "Test Case 5a - Execute script from stdin redirected using '<'";
        invoke "${APL}" -s -- 16 ÷ 4 '<' test_5.txt '&>' "case_5a.log";
        invoke diff case_5a.log test_5.ref;

        herald "Test Case 5b - Execute script from stdin redirected using '|'";
        invoke cat test_5.txt '|' "${APL}" -s -- 16 ÷ 4 '&>' "case_5b.log";
        invoke diff case_5b.log test_5.ref;

        herald "Test Case 5c - Execute script using command line flag";
        invoke "${APL}" -s -f test_5.txt -- 16 ÷ 4 '&>' "case_5c.log";
        invoke diff case_5c.log test_5.ref;

        herald "Test Case 5d - Execute implicit script using #!";
        invoke ./test_5.apl -- 16 ÷ 4 '&>' "case_5d.log";
        invoke diff case_5d.log test_5.ref;
        ;;

      (6)
        narrative <<- EOF
	The following test cases check what happens when a script is used
	with the -s option and an APL error occurs.

	In all cases:
	    a) the offending line should be output as if -s had not been specified
	    b) the file name and line number should also be output
	    c) execution of the scripts stops and the interpreter exists
	EOF

        herald "Test Case 6a - Execute script from stdin redirected using '<'";
        invoke "${APL}" -s -- 16 ÷ 4 '<' test_6.txt '&>' "case_6a.log" '||' true;
        invoke diff case_6a.log test_6.ref;

        herald "Test Case 6b - Execute script from stdin redirected using '|'";
        invoke cat test_6.txt '|' "${APL}" -s -- 16 ÷ 4 '&>' "case_6b.log" '||' true;
        invoke diff case_6b.log test_6.ref;

        herald "Test Case 6c - Execute script using command line flag";
        invoke "${APL}" -s -f test_6.txt -- 16 ÷ 4 '&>' "case_6c.log" '||' true;
        invoke diff case_6c.log test_6c.ref;

        herald "Test Case 6d - Execute implicit script using #!";
        invoke ./test_6.apl -- 16 ÷ 4 '&>' "case_6d.log" '||' true;
        invoke diff case_6d.log test_6d.ref;
        ;;

      (7)
        narrative <<- EOF
	The following test cases check output redirection through tee will
	capture a session log (including a mv Python stack trace if necessary).
	EOF

        herald "Test Case 7a - Execute script from stdin redirected using '<'";
        invoke "${APL}" '<' test_7.txt '|&' tee -i case_7a.log
        invoke diff case_7a.log test_7.ref;

        herald "Test Case 7b - Execute script from stdin redirected using '|'";
        invoke cat test_7.txt '|' "${APL}" '|&' tee -i case_7b.log;
        invoke diff case_7b.log test_7.ref;

        herald "Test Case 7c - Execute script using command line flag";
        note "... type ^D to exit the APL interpreter";
        invoke "${APL}" -f test_7.txt '|&' tee -i case_7c.log;
        invoke diff case_7c.log test_7i.ref;

        herald "Test Case 7d - Execute implicit script using #!";
        note "... type ^D to exit the APL interpreter";
        invoke ./test_7.apl '|&' tee -i case_7d.log;
        invoke diff case_7d.log test_7i.ref;
        ;;

      (8)
        narrative <<- EOF
	The following test cases check that explicit output occurs even
	when script or silent mode as been requested.
	EOF

        herald "Test Case 8a - Execute script from stdin redirected using '<'";
        invoke "${APL}" -s '<' test_8.txt '&>' case_8a.log;
        invoke diff case_8a.log test_8.ref;

        herald "Test Case 8b - Execute script from stdin redirected using '|'";
        invoke cat test_8.txt '|' "${APL}" -s '&>' case_8b.log;
        invoke diff case_8b.log test_8.ref;

        herald "Test Case 8c - Execute script using command line flag";
        invoke "${APL}" -s -f test_8.txt '&>' case_8c.log;
        invoke diff case_8c.log test_8.ref;

        herald "Test Case 8d - Execute implicit script using #!";
        invoke ./test_8.apl '&>' case_8d.log;
        invoke diff case_8d.log test_8.ref;
        ;;

      (9)
        narrative <<- EOF
	These test cases check recognition of flags including -h and --help.
	Also redirection from a file that is not readable.
	EOF

        herald "Test Case 9a - Response to an unrecognised short form flag";
        invoke "${APL}" -x '||' true;

        herald "Test Case 9b - Response to an unrecognised long form flag";
        invoke "${APL}" --extra '||' true;

        herald "Test Case 9c - Check recognition of short form flags";
        note "... type ^D to exit the APL interpreter";
        invoke "${APL}" -s -v;

        herald "Test Case 9d - Check recognition of long form flags";
        note "... type ^D to exit the APL interpreter";
        invoke "${APL}" --silent --verbose --script;

        herald "Test Case 9e - Check recognition of short form help flag";
        invoke "${APL}" -h '&>' case_9e.log;
        invoke diff case_9e.log test_9.ref;

        herald "Test Case 9f - Check recognition of long form help flag";
        invoke "${APL}" --help '&>' case_9f.log;
        invoke diff case_9f.log test_9.ref;

        herald "Test Case 9g - Check recognition of short form version flag";
        invoke "${APL}" -V;

        herald "Test Case 9h - Check recognition of long form version flag";
        invoke "${APL}" --Version;

        herald "Test Case 9i - Response to input redirection to a file that cannot be read";
        invoke "${APL}" -f test_9.txt '||' true;
        ;;
    esac
done

# EOF
